import groovy.json.JsonSlurper
buildscript {
  repositories {
    mavenLocal()
    jcenter()
  }
  dependencies {
    classpath group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.5.8'
  }
}
plugins {
  id 'com.github.node-gradle.node' version '1.5.1'
  id 'idea'
  id 'maven-publish'
  id 'pl.allegro.tech.build.axion-release' version '1.9.3'
  id 'io.jumpco.open.gradle.s3' version '1.1.1'
}

repositories {
  mavenLocal()
  jcenter()
  mavenCentral()
}

idea {
  module {
    excludeDirs += files('node_modules')
  }
}

group = 'za.co.metropolitan'
description = 'Request Tracker UI'

scmVersion {
    tag {
        prefix = rootProject.name
    }
    nextVersion {
        suffix = 'SNAPSHOT'
        separator = '-'
    }
    checks {
        uncommittedChanges = false
        aheadOfRemote = false
        snapshotDependencies = false
    }
    repository {
        customUsername = findProperty('release.customUsername') ?: System.env.SCM_USERNAME
        customPassword = findProperty('release.customPassword') ?: System.env.SCM_PASSWORD
    }
}

if (project.findProperty('buildVersion') == 'LOCAL-SNAPSHOT') {
    project.version = 'LOCAL-SNAPSHOT'
} else {
    project.version = scmVersion.version
}


def buildDate = new java.text.SimpleDateFormat('yyyy-MM-dd HH:mm').format(new Date())

task cleanResources(type: Delete) {
  delete 'build/resources'
}

node {
  version = "${node_version}"
  npmVersion = "${npm_version}"
  download = true
}

task angularBuild(type: NodeTask) {
  group = 'angular'
  dependsOn npm_install
  script = file("$rootProject.projectDir/node_modules/@angular/cli/bin/ng")
  args = ['run', 'request-tracker-ui:build', '--optimization=false', '--build-optimizer=false']
  if (logger.isEnabled(LogLevel.INFO)) {
    args << '--verbose'
  }
}

task angularBuildProd(type: NodeTask) {
  group = 'angular'
  dependsOn npm_install
  script = file("$rootProject.projectDir/node_modules/@angular/cli/bin/ng")
  args = ['run', 'request-tracker-ui:build:production', '--optimization=false', '--aot=false', '--build-optimizer=false']
  if (logger.isEnabled(LogLevel.INFO)) {
    args << '--verbose'
  }
  inputs.dir file('node_modules')
  inputs.file file('angular.json')
  outputs.dir file('dist-prod')
}

task angularBuildTest(type: NodeTask) {
  group = 'angular'
  dependsOn npm_install
  script = file("$rootProject.projectDir/node_modules/@angular/cli/bin/ng")
  args = ['run', 'request-tracker-ui:build:test', '--optimization=false', '--aot=false', '--build-optimizer=false']
  if (logger.isEnabled(LogLevel.INFO)) {
    args << '--verbose'
  }
  inputs.dir file('node_modules')
  inputs.file file('angular.json')
  outputs.dir file('dist-test')
}

task angularServe(type: NodeTask) {
  group = 'angular'
  dependsOn npm_install
  script = file("$rootProject.projectDir/node_modules/@angular/cli/bin/ng")
  args = ['run', 'request-tracker-ui:serve', '--host=0.0.0.0', '--port=8100']
  if (logger.isEnabled(LogLevel.INFO)) {
    args << '--verbose'
  }
}

task ngTest(type: NodeTask, dependsOn: angularBuild) {
  group 'angular'
  dependsOn npm_install
  script = file("$rootProject.projectDir/node_modules/@angular/cli/bin/ng")
  args = ['test', "--watch=false"]
  if (logger.isEnabled(LogLevel.INFO)) {
    args += ['--verbose']
  }
}

def distZipPath = buildDir
def distZipFile = "${project.name}-${project.version}.zip"

def jsonSlurper = new JsonSlurper()
def angular = jsonSlurper.parseText(file('angular.json').text)
logger.info("angular=$angular")
def distFolder = angular.projects[project.name].architect.build.options.outputPath ?: 'dist'
logger.lifecycle("distFolder=$distFolder")

task distZip(type: Zip, dependsOn: angularBuild) {
  group 'build'
  archiveFileName = distZipFile
  destinationDirectory = file(distZipPath)
  from file("$project.projectDir/$distFolder")
  doFirst {
    logger.warn('DON\'T DEPLOY THIS BUILD TO A REMOTE SERVER')
  }
}

def distProdFolder = angular.projects[project.name].architect.build.configurations.production.outputPath ?: 'dist-prod'
logger.lifecycle("distProdFolder=$distProdFolder")

task distZipProd(type: Zip, dependsOn: angularBuildProd) {
  group 'build'
  archiveFileName = distZipFile
  archiveClassifier = 'prod'
  destinationDirectory = file(distZipPath)
  from file("$project.projectDir/$distProdFolder")
}

def distTestFolder = angular.projects[project.name].architect.build.configurations.test.outputPath ?: 'dist-test'
logger.lifecycle("distTestFolder=$distTestFolder")

task distZipTest(type: Zip, dependsOn: angularBuildTest) {
  group 'build'
  archiveFileName = distZipFile
  archiveClassifier = 'test'
  destinationDirectory = file(distZipPath)
  from file("$project.projectDir/$distTestFolder")
}

task cleanDist(type: Delete) {
  group 'build'
  delete file("$project.projectDir/$distFolder")
}

task cleanDistTest(type: Delete) {
  group 'build'
  delete file("$project.projectDir/$distTestFolder")
}

task cleanDistProd(type: Delete) {
  group 'build'
  delete file("$project.projectDir/$distProdFolder")
}

if(project.getTasksByName('clean', false).empty) {
  task clean {
    group 'build'
  }
}

clean.dependsOn cleanDistProd
clean.dependsOn cleanDistTest
clean.dependsOn cleanDist

if(project.getTasksByName('assemble', false).empty) {
  task assemble {
    group 'build'
  }
}

assemble.dependsOn angularBuildProd
assemble.dependsOn angularBuildTest

defaultTasks 'publishToMavenLocal'

publishing {
    publications {
        maven(MavenPublication) {
            groupId = project.group
            artifactId = project.name
            artifact source: distZipTest, extension: 'zip', classifier: 'test'
            artifact source: distZipProd, extension: 'zip', classifier: 'prod'
        }
    }
    repositories {
        maven {
          def snapShotRepo = 'https://jumpco.jfrog.io/jumpco/list/libs-snapshot-local'
          def releaseRepo = 'https://jumpco.jfrog.io/jumpco/list/libs-release-local'
          credentials {
            username findProperty('jumpCoMavenUser') ?: System.env.MAVEN_USER
            password findProperty('jumpCoMavenPassword') ?: System.env.MAVEN_PASSWORD
          }
          url project.version.endsWith('SNAPSHOT') ? snapShotRepo : releaseRepo
        }
    }
}


import groovy.json.JsonSlurper

def manifestDir = new File(project.buildDir, 'manifest')
def versionManifest = new File(manifestDir, 'maven-metadata.xml')
def deployDir = new File(project.buildDir, 'deploy')

def testContentDir = new File(project.buildDir, 'test-content')
def prodContentDir = new File(project.buildDir, 'prod-content')
def destDir = '/var/www/html/request-tracker-ui'

task testDeploy(type: Exec) {
  group = 'deploy'
  executable 'scp'
  args testContentDir, "$deployUser@$deployHost:$destDir"
}

task productionDeploy(type:Exec) {
  group = 'deploy'
  executable 'scp'
  args prodContentDir, "$deployUser@$deployHost:$destDir"
}

if(project.findProperty('deployVersion') == 'CURRENT') {
  task extractTestBuild(type: Copy, dependsOn: angularBuildTest) {
      group = 'deploy'
      from distTestFolder
      into testContentDir
  }
  task extractProdBuild(type: Copy, dependsOn: angularBuildProd) {
        group = 'deploy'
        from distProdFolder
        into prodContentDir
  }
  testDeploy.dependsOn extractTestBuild
  productionDeploy.dependsOn extractProdBuild
} else {
  task artifactDownloadTask() {
    group = 'deploy'
    doFirst {
        def repoBaseUrl = project.findProperty('deployVersion') == 'RELEASE' ?
          'https://jumpco.jfrog.io/jumpco/libs-release-local' :
          'https://jumpco.jfrog.io/jumpco/libs-snapshot-local'
        def metaData = "$repoBaseUrl/${project.group.replace('.','/')}/${project.name}/maven-metadata.xml"
        gradle.ext.repoBaseUrl = repoBaseUrl
        logger.lifecycle "reading:$metaData"
        logger.info "mavenUser=${findProperty('jumpCoMavenUser')?:System.env.MAVEN_USER}"
        def url = new URL(metaData)
        def urlConnection = url.openConnection()
        urlConnection.setRequestProperty('X-JFrog-Art-Api', jumpCoMavenPassword)
        def doc = new XmlSlurper().parse(urlConnection.getInputStream())
        gradle.ext.latestVersion = project.findProperty('deployVersion') == 'RELEASE' ?
                                  doc.versioning.release.text() : project.findProperty('deployVersion') == 'LATEST' ?
                                  doc.versioning.latest.text() : project.findProperty('deployVersion')
      logger.lifecycle "determineVersion:${deployVersion}=${gradle.ext.latestVersion}"
      deployDir.mkdirs()
    }
    doLast {
      logger.lifecycle("artifactDownloadTask:${gradle.ext.latestVersion}")
      ant.ant(antfile:'build.xml', dir: project.projectDir) {
        property(name:'latestVersion', value:gradle.ext.latestVersion)
        property(name:'deployDir', value:deployDir.path)
        property(name:'prodContent', value:prodContentDir.path)
        property(name:'testContent', value:testContentDir.path)
      }
    }
    inputs.file versionManifest
  }

  testDeploy.dependsOn artifactDownloadTask
  productionDeploy.dependsOn artifactDownloadTask
}
